package io.jenkins.plugins.cbri;

import hudson.FilePath;
import hudson.model.TaskListener;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.lang.StringBuilder;

/**
 * Convert the metrics generated by Understand into a CbriAction object
 */
public class CbriMetrics {

    private final static String UND_DIR = "understand";

    public CbriMetrics() {

    }

    public CbriAction loadMetrics(FilePath workspace, TaskListener listener) throws IOException, InterruptedException {

        HashMap<String, String> map = readMetrics(workspace, listener);
        CbriAction action = new CbriAction();

        action.today = new Date();

        //Architecture
        action.architectureType = map.get("Architecture Type");
        action.propagationCost = getDouble("Propagation Cost", map);
        action.core = isCore(action.architectureType);
        if(action.core)
            action.coreSize = getDouble("Core Size", map);
        else
            action.coreSize = getDouble("Central Size", map);

        //Complexity
        action.percentFilesOverlyComplex = getDouble("Overly Complex Files", map);
        action.duplicateUloc = getInt("Duplicate Useful Lines of Code", map);
        action.uloc = getInt("Useful Lines of Code (ULOC)", map);
        action.percentDuplicateUloc = 100.0 * ((double) action.duplicateUloc) / ((double) action.uloc);

        //Clarity
        action.usefulCommentDensity = getDouble("Useful Comment Density", map);
        action.usefulLinesComments = (int) Math.round((action.usefulCommentDensity / 100.0) * action.uloc);

        //Counts
        action.numClasses = getInt("Classes", map);
        action.numFiles = getInt("Files", map);
        action.numFilesInCore = (int) Math.round(action.numFiles * (action.coreSize / 100.0));
        action.numFilesOverlyComplex = (int) Math.round(action.numFiles * (action.percentFilesOverlyComplex / 100.0));

        //File Tree Map
        action.fileTreeMap = readTreeMap(workspace, listener);

        return action;
    }

    protected String readTreeMap(FilePath workspace, TaskListener listener) throws IOException, InterruptedException {

        StringBuilder toReturn = new StringBuilder();

        //String filename = coreMetricsDir + File.separator + "treemap.html";
        FilePath metricsFile = new FilePath(workspace, UND_DIR + File.separator + "treemap.html");
        listener.getLogger().println("Attempting to read treemap from: " + metricsFile);

        InputStream in = metricsFile.read();
        Reader reader = new InputStreamReader(in, StandardCharsets.UTF_8);
        BufferedReader br = new BufferedReader(reader);

        String line = br.readLine(); // Reading header, Ignoring
        int node = 0; //ignore first two lines with "[]"
        while ((line = br.readLine()) != null && !line.isEmpty()) {
            line = line.replaceAll("\'", "").replaceAll(" ", "");
            int index1 = line.indexOf('[');
            int index2 = line.indexOf(']');
            if (index1 > -1 && index2 > -1 && node++ > 1) {
                toReturn.append(line.substring(index1 + 1, index2));
                toReturn.append("\n");
            }
        }

        br.close();
        reader.close();
        in.close();

        return toReturn.toString();
    }

    /**
     *
     * @return false if not a core architecture type, true otherwise
     */
    protected boolean isCore(String architecture_type) {

        if(architecture_type.contains("Core-Periphery"))
            return true;

        return false;
    }
    /**
     * @return the int value of the given field, -1 if invalid.
     */
    protected int getInt(String field, HashMap<String, String> map) {
        String value = map.get(field);
        if(value == null || value.isEmpty())
            return -1;

        Integer iValue = Integer.valueOf(value);
        return iValue;
    }

    /**
     * @return the int value of the given field, -1 if invalid.
     */
    protected double getDouble(String field, HashMap<String, String> map) {
        String value = map.get(field);
        if(value == null || value.isEmpty())
            return -1;

        double dValue = Double.valueOf(value);
        return dValue;
    }

    /**
     * Read in values from the file 'projectMetrics.csv' if it exists.
     *
     * e.g.
     * Metric Name, Value
     * "Project Name","Understand"
     * "Propagation Cost","44.6"
     * "Architecture Type","Core-Periphery"
     * "Core Size","44.3%"
     * "Central Size","46.2%"
     * "Software Lines of Code (SLOC)","42,887"
     * "Useful Lines of Code (ULOC)","32,509"
     * "Duplicate Useful Lines of Code","3,849"
     * "Useful Comment Density","26%"
     * "Classes","535"
     * "Files","366"
     * "Overly Complex Files","7%"
     * "Overly Complex Core Files","14%"
     * "Overly Complex Central Files","14%"
     */
    public HashMap<String, String>  readMetrics(FilePath workspace, TaskListener listener) throws IOException, InterruptedException {

        HashMap<String, String> map = new HashMap<>();

        //String filename = coreMetricsDir + File.separator + "projectMetrics.csv";
        FilePath metricsFile = new FilePath(workspace, UND_DIR + File.separator + "projectMetrics.csv");
        listener.getLogger().println("Attempting to read metrics from: " + metricsFile);

        InputStream in = metricsFile.read();
        Reader reader = new InputStreamReader(in, StandardCharsets.UTF_8);
        BufferedReader br = new BufferedReader(reader);

        String line = br.readLine(); // Reading header, Ignoring
        while ((line = br.readLine()) != null && !line.isEmpty()) {
            String[] fields = line.split("\",\""); //Look for ","
            if (fields.length != 2)
                throw new IOException("Incorrectly formatted projectMetrics.csv, line: " + line);
            String name = fields[0].replaceFirst("\"", ""); // Remove leading "
            String value = fields[1].substring(0, fields[1].length() - 1); // Remove training "
            value = value.replaceAll(",", "");
            value = value.replaceAll("%", "");
            value = value.trim();

            map.put(name, value);
            listener.getLogger().println(name + " " + value);

        }
        br.close();
        reader.close();
        in.close();

        return map;
    }
}
